<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>ğŸ„ Frozen Wonderland</title>
  <style>
    :root{
      --bg1:#071321; --bg2:#0b2a3b;
      --glass: rgba(255,255,255,.12);
      --glass2: rgba(255,255,255,.18);
      --text:#eaf6ff;
      --muted: rgba(234,246,255,.75);
      --accent:#8ee6ff;
      --danger:#ffb3b3;
    }
    html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"PingFang SC","Microsoft YaHei",sans-serif;background:radial-gradient(1200px 800px at 50% 20%, #124f6a 0%, var(--bg2) 45%, var(--bg1) 100%);color:var(--text);overflow:hidden;}
    #scene{position:fixed;inset:0;display:block;}
    #ui-layer{
      position:fixed; inset:0;
      display:flex; align-items:flex-start; justify-content:center;
      pointer-events:none;
    }
    .panel{
      pointer-events:auto;
      margin-top:20px;
      width:min(980px,92vw);
      border-radius:18px;
      background:linear-gradient(180deg,var(--glass2),var(--glass));
      backdrop-filter: blur(10px);
      box-shadow: 0 18px 50px rgba(0,0,0,.35);
      border: 1px solid rgba(255,255,255,.15);
      padding:16px 18px 14px;
      display:grid;
      grid-template-columns: 1fr auto;
      gap:12px;
      align-items:center;
    }
    h1{
      margin:0;
      font-size:18px;
      letter-spacing:.3px;
      display:flex; gap:10px; align-items:center;
      user-select:none;
    }
    h1 span.tag{
      font-size:12px;
      padding:4px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.18);
      color:var(--muted);
      background:rgba(0,0,0,.12);
    }
    .controls{display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:flex-end;}
    button{
      border:1px solid rgba(255,255,255,.18);
      background:rgba(0,0,0,.18);
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      font-size:13px;
      cursor:pointer;
      transition:.15s transform,.15s background;
      user-select:none;
    }
    button:hover{background:rgba(0,0,0,.28); transform: translateY(-1px);}
    button:active{transform: translateY(0px);}
    button.primary{
      background:rgba(142,230,255,.18);
      border-color: rgba(142,230,255,.35);
    }
    button.primary:hover{background:rgba(142,230,255,.25);}
    .hint{
      grid-column:1 / -1;
      margin-top:2px;
      color:var(--muted);
      font-size:12.5px;
      line-height:1.35;
    }
    .hint b{color:var(--text);}
    .warn{
      display:none;
      margin-top:8px;
      padding:10px 12px;
      border-radius:12px;
      background:rgba(255,120,120,.10);
      border:1px solid rgba(255,120,120,.25);
      color:rgba(255,220,220,.95);
      font-size:12.5px;
      line-height:1.35;
    }

    /* Webcam preview (optional) */
    #webcam-wrapper{
      position:fixed;
      right:14px; bottom:14px;
      width:180px; height:130px;
      border-radius:14px;
      overflow:hidden;
      border:1px solid rgba(255,255,255,.20);
      background:rgba(0,0,0,.25);
      box-shadow: 0 14px 35px rgba(0,0,0,.35);
      opacity:0; /* default hidden; will show after camera starts */
      transition: opacity .25s ease;
      pointer-events:none;
    }
    #webcam{display:none;}
    #webcam-preview{width:100%;height:100%;display:block;}

    /* Tiny snow sparkle */
    .footer{
      position:fixed; left:16px; bottom:14px;
      color: rgba(234,246,255,.65);
      font-size:12px;
      user-select:none;
      pointer-events:none;
      text-shadow: 0 2px 10px rgba(0,0,0,.25);
    }
  </style>
</head>

<body>
  <canvas id="scene"></canvas>

  <div id="ui-layer">
    <div class="panel">
      <div>
        <h1>ğŸ„ Frozen Wonderland <span class="tag" id="statusTag">Hand: OFF</span></h1>
      </div>

      <div class="controls">
        <button class="primary" id="btnStart">å¯ç”¨æ‰‹åŠ¿ / æ‘„åƒå¤´</button>
        <button id="btnStop">å…³é—­æ‘„åƒå¤´</button>
        <button id="btnPhoto">ä¸Šä¼ ç…§ç‰‡åšèƒŒæ™¯</button>
      </div>

      <div class="hint">
        è¯´æ˜ï¼šç”±äºæµè§ˆå™¨æƒé™ç­–ç•¥ï¼Œæ‘„åƒå¤´å¿…é¡»ç”±<b>ç‚¹å‡»</b>è§¦å‘æ‰èƒ½å¼¹å‡ºæˆæƒæ¡†ï¼ˆGitHub Pages / iOS Safari å°¤å…¶å¦‚æ­¤ï¼‰ã€‚
        ç‚¹å‡»ã€Œå¯ç”¨æ‰‹åŠ¿ / æ‘„åƒå¤´ã€åå…è®¸ Cameraï¼Œå³å¯ç”¨æ‰‹åŠ¿äº§ç”Ÿé£/é­”æ³•æ•ˆæœã€‚
      </div>

      <div class="warn" id="warnBox"></div>
    </div>
  </div>

  <div id="webcam-wrapper">
    <video id="webcam" playsinline></video>
    <canvas id="webcam-preview"></canvas>
  </div>

  <div class="footer">â„ï¸ Tip: iOS Safari éœ€è¦åœ¨â€œç‚¹å‡»â€åæ‰ä¼šçœŸæ­£å¼€å§‹ video.play()</div>

  <input id="fileInput" type="file" accept="image/*" style="display:none" />

  <!-- MediaPipe Tasks Vision -->
  <script type="module">
    import { FilesetResolver, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";

    // -----------------------------
    // Canvas scene: snow + tree
    // -----------------------------
    const canvas = document.getElementById("scene");
    const ctx = canvas.getContext("2d");

    function resize() {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      canvas.width = Math.floor(innerWidth * dpr);
      canvas.height = Math.floor(innerHeight * dpr);
      canvas.style.width = innerWidth + "px";
      canvas.style.height = innerHeight + "px";
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }
    window.addEventListener("resize", resize);
    resize();

    // snow particles
    const snow = [];
    const SNOW_N = Math.min(400, Math.floor((innerWidth * innerHeight) / 3500));
    for (let i = 0; i < SNOW_N; i++) {
      snow.push({
        x: Math.random() * innerWidth,
        y: Math.random() * innerHeight,
        r: 0.8 + Math.random() * 2.2,
        vy: 0.6 + Math.random() * 1.8,
        vx: -0.3 + Math.random() * 0.6,
        phase: Math.random() * Math.PI * 2
      });
    }

    // â€œhand windâ€ state
    let windX = 0;    // -1..1
    let windY = 0;    // -1..1
    let magic = 0;    // 0..1
    let bgImage = null;

    function drawTree(cx, cy, scale) {
      // trunk
      ctx.save();
      ctx.translate(cx, cy);
      ctx.scale(scale, scale);

      // trunk
      ctx.fillStyle = "rgba(120,72,38,.95)";
      ctx.beginPath();
      ctx.roundRect(-18, 70, 36, 55, 10);
      ctx.fill();

      // layers
      const layers = [
        { y:-10, w:200, h:150, c:"rgba(22,120,84,.95)" },
        { y: 35, w:240, h:170, c:"rgba(18,100,72,.95)" },
        { y: 90, w:280, h:190, c:"rgba(14,86,62,.95)" },
      ];
      for (const L of layers) {
        ctx.fillStyle = L.c;
        ctx.beginPath();
        ctx.moveTo(0, L.y - L.h/2);
        ctx.lineTo(-L.w/2, L.y + L.h/2);
        ctx.lineTo(L.w/2, L.y + L.h/2);
        ctx.closePath();
        ctx.fill();
      }

      // star
      const t = performance.now() * 0.002;
      const glow = 0.45 + 0.55 * Math.sin(t);
      ctx.save();
      ctx.translate(0, -105);
      ctx.rotate(t * 0.2);
      ctx.fillStyle = `rgba(255, 232, 160, ${0.65 + 0.35*glow})`;
      ctx.shadowColor = "rgba(255,232,160,.9)";
      ctx.shadowBlur = 22;
      ctx.beginPath();
      const spikes = 5, outer = 18, inner = 7;
      for (let i=0;i<spikes*2;i++){
        const ang = (Math.PI/spikes)*i;
        const rad = (i%2===0)?outer:inner;
        ctx.lineTo(Math.cos(ang)*rad, Math.sin(ang)*rad);
      }
      ctx.closePath();
      ctx.fill();
      ctx.restore();

      // ornaments
      const ornaments = [
        {x:-55,y:20,c:"rgba(255,120,160,.9)"},
        {x: 62,y:55,c:"rgba(120,220,255,.9)"},
        {x:-80,y:95,c:"rgba(255,210,120,.9)"},
        {x: 25,y:105,c:"rgba(180,255,180,.9)"},
        {x: 0,y:45,c:"rgba(220,180,255,.9)"},
      ];
      for (const o of ornaments) {
        ctx.save();
        ctx.translate(o.x, o.y);
        ctx.fillStyle = o.c;
        ctx.shadowColor = o.c;
        ctx.shadowBlur = 16 * (0.2 + 0.8*magic);
        ctx.beginPath();
        ctx.arc(0,0,8,0,Math.PI*2);
        ctx.fill();
        ctx.restore();
      }

      ctx.restore();
    }

    function draw() {
      ctx.clearRect(0,0,innerWidth,innerHeight);

      // background image
      if (bgImage) {
        // cover
        const cw = innerWidth, ch = innerHeight;
        const iw = bgImage.width, ih = bgImage.height;
        const s = Math.max(cw/iw, ch/ih);
        const w = iw*s, h = ih*s;
        ctx.globalAlpha = 0.45;
        ctx.drawImage(bgImage, (cw-w)/2, (ch-h)/2, w, h);
        ctx.globalAlpha = 1;
      }

      // subtle vignette
      const g = ctx.createRadialGradient(innerWidth/2, innerHeight*0.35, 80, innerWidth/2, innerHeight*0.35, Math.max(innerWidth,innerHeight));
      g.addColorStop(0, "rgba(255,255,255,.03)");
      g.addColorStop(1, "rgba(0,0,0,.25)");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,innerWidth,innerHeight);

      // draw tree (center bottom)
      drawTree(innerWidth/2, innerHeight*0.62, Math.min(innerWidth,innerHeight)/700);

      // snow
      const now = performance.now() * 0.001;
      for (const s of snow) {
        // wind from hand
        const wx = windX * 2.4;
        const wy = windY * 0.6;

        s.phase += 0.01;
        s.x += s.vx + Math.sin(s.phase + now) * 0.3 + wx;
        s.y += s.vy + wy;

        if (s.y > innerHeight + 8) { s.y = -10; s.x = Math.random()*innerWidth; }
        if (s.x < -20) s.x = innerWidth + 20;
        if (s.x > innerWidth + 20) s.x = -20;

        ctx.beginPath();
        const alpha = 0.35 + 0.4 * (0.5 + 0.5*Math.sin(now + s.phase));
        ctx.fillStyle = `rgba(255,255,255,${alpha})`;
        ctx.arc(s.x, s.y, s.r*(1+0.35*magic), 0, Math.PI*2);
        ctx.fill();
      }

      // magic glow overlay
      if (magic > 0.02) {
        ctx.globalAlpha = 0.15 * magic;
        ctx.fillStyle = "rgba(142,230,255,1)";
        ctx.fillRect(0,0,innerWidth,innerHeight);
        ctx.globalAlpha = 1;
      }

      // decay magic slowly
      magic *= 0.96;

      requestAnimationFrame(draw);
    }
    requestAnimationFrame(draw);

    // -----------------------------
    // UI
    // -----------------------------
    const btnStart = document.getElementById("btnStart");
    const btnStop = document.getElementById("btnStop");
    const btnPhoto = document.getElementById("btnPhoto");
    const fileInput = document.getElementById("fileInput");
    const warnBox = document.getElementById("warnBox");
    const statusTag = document.getElementById("statusTag");

    function showWarn(msg) {
      warnBox.style.display = "block";
      warnBox.textContent = msg;
    }
    function clearWarn() {
      warnBox.style.display = "none";
      warnBox.textContent = "";
    }

    btnPhoto.addEventListener("click", () => fileInput.click());
    fileInput.addEventListener("change", (e) => {
      const f = e.target.files?.[0];
      if (!f) return;
      const url = URL.createObjectURL(f);
      const img = new Image();
      img.onload = () => { bgImage = img; URL.revokeObjectURL(url); };
      img.src = url;
    });

    // -----------------------------
    // MediaPipe hand tracking (must be click-started)
    // -----------------------------
    const video = document.getElementById("webcam");
    const webcamCanvas = document.getElementById("webcam-preview");
    const webcamCtx = webcamCanvas.getContext("2d");
    webcamCanvas.width = 180;
    webcamCanvas.height = 130;

    let handLandmarker = null;
    let running = false;
    let streamRef = null;

    async function initHandLandmarker() {
      if (handLandmarker) return;
      const vision = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
      );
      handLandmarker = await HandLandmarker.createFromOptions(vision, {
        baseOptions: {
          modelAssetPath:
            "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
          delegate: "GPU",
        },
        runningMode: "VIDEO",
        numHands: 1,
      });
    }

    async function startCameraAndHands() {
      clearWarn();
      try {
        await initHandLandmarker();

        if (!navigator.mediaDevices?.getUserMedia) {
          showWarn("å½“å‰æµè§ˆå™¨ä¸æ”¯æŒ getUserMediaï¼Œæ— æ³•å¯ç”¨æ‘„åƒå¤´ã€‚å»ºè®®ä½¿ç”¨ Chrome / Edge / Safari æ–°ç‰ˆã€‚");
          return;
        }

        streamRef = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: "user" },
          audio: false
        });

        video.srcObject = streamRef;

        // iOS Safari: ensure play is in click handler
        await video.play();

        document.getElementById("webcam-wrapper").style.opacity = 1;
        running = true;
        statusTag.textContent = "Hand: ON";

        requestAnimationFrame(predictLoop);
      } catch (err) {
        console.error(err);
        const name = err?.name || "Error";
        const msg = err?.message || String(err);
        if (name === "NotAllowedError" || name === "PermissionDeniedError") {
          showWarn("æ‘„åƒå¤´æƒé™è¢«æ‹’ç»ï¼šè¯·åœ¨æµè§ˆå™¨åœ°å€æ çš„æƒé™è®¾ç½®ä¸­å…è®¸ Cameraï¼Œç„¶åå†ç‚¹ä¸€æ¬¡æŒ‰é’®ã€‚");
        } else if (name === "NotFoundError" || name === "DevicesNotFoundError") {
          showWarn("æœªæ£€æµ‹åˆ°æ‘„åƒå¤´è®¾å¤‡ï¼ˆNotFoundErrorï¼‰ã€‚å¦‚æœæ˜¯ç”µè„‘è¯·ç¡®è®¤æœ‰æ‘„åƒå¤´ï¼›æ‰‹æœºè¯·æ£€æŸ¥æƒé™ã€‚");
        } else if (name === "NotReadableError") {
          showWarn("æ‘„åƒå¤´å¯èƒ½è¢«å…¶å®ƒåº”ç”¨å ç”¨ï¼ˆNotReadableErrorï¼‰ã€‚è¯·å…³é—­å ç”¨æ‘„åƒå¤´çš„åº”ç”¨åé‡è¯•ã€‚");
        } else {
          showWarn(`æ— æ³•å¼€å¯æ‘„åƒå¤´ï¼š${name} / ${msg}`);
        }
      }
    }

    function stopCamera() {
      running = false;
      statusTag.textContent = "Hand: OFF";
      windX = 0; windY = 0; // reset
      if (streamRef) {
        for (const t of streamRef.getTracks()) t.stop();
        streamRef = null;
      }
      video.srcObject = null;
      document.getElementById("webcam-wrapper").style.opacity = 0;
    }

    btnStart.addEventListener("click", startCameraAndHands);
    btnStop.addEventListener("click", stopCamera);

    // Hand â†’ wind mapping
    function landmarksToWind(landmarks) {
      // use wrist (0) and index fingertip (8)
      const wrist = landmarks[0];
      const tip = landmarks[8];

      // vector from wrist to fingertip
      const dx = tip.x - wrist.x;
      const dy = tip.y - wrist.y;

      // map to wind; clamp
      const wx = Math.max(-1, Math.min(1, dx * 3.0));
      const wy = Math.max(-1, Math.min(1, dy * 3.0));

      return { wx, wy };
    }

    // simple pinch detection: distance between thumb tip (4) and index tip (8)
    function isPinching(landmarks) {
      const a = landmarks[4], b = landmarks[8];
      const dist = Math.hypot(a.x - b.x, a.y - b.y);
      return dist < 0.05; // threshold; adjust if needed
    }

    let lastVideoTime = -1;
    async function predictLoop() {
      if (!running || !handLandmarker) return;

      // draw preview
      webcamCtx.clearRect(0, 0, webcamCanvas.width, webcamCanvas.height);
      webcamCtx.save();
      // mirror
      webcamCtx.translate(webcamCanvas.width, 0);
      webcamCtx.scale(-1, 1);
      webcamCtx.drawImage(video, 0, 0, webcamCanvas.width, webcamCanvas.height);
      webcamCtx.restore();

      const nowMs = performance.now();
      if (video.currentTime !== lastVideoTime) {
        lastVideoTime = video.currentTime;

        const results = handLandmarker.detectForVideo(video, nowMs);

        if (results?.landmarks?.length) {
          const lm = results.landmarks[0];

          // update wind
          const { wx, wy } = landmarksToWind(lm);
          // smooth
          windX = windX * 0.85 + wx * 0.15;
          windY = windY * 0.85 + wy * 0.15;

          // pinch makes magic
          if (isPinching(lm)) magic = Math.min(1, magic + 0.18);

          // optionally draw a dot on fingertip
          const tip = lm[8];
          const x = (1 - tip.x) * webcamCanvas.width; // mirrored
          const y = tip.y * webcamCanvas.height;
          webcamCtx.beginPath();
          webcamCtx.fillStyle = "rgba(142,230,255,.95)";
          webcamCtx.arc(x, y, 5, 0, Math.PI*2);
          webcamCtx.fill();
        } else {
          // decay wind to zero if hand not found
          windX *= 0.92;
          windY *= 0.92;
        }
      }

      requestAnimationFrame(predictLoop);
    }

    // Optional: stop tracks when leaving
    window.addEventListener("visibilitychange", () => {
      if (document.hidden) stopCamera();
    });

  </script>
</body>
</html>
